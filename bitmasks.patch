From d88310e418c6dd09080462d36b404481afa50c01 Mon Sep 17 00:00:00 2001
From: oers <stmura+git@gmail.com>
Date: 27.04.2012 13:50:21

BitMasks

diff --git a/src/main/java/de/earthlingz/games/reversi/joinfork/Board.java b/src/main/java/de/earthlingz/games/reversi/joinfork/Board.java
index ee109ae..44305e5 100644
--- a/src/main/java/de/earthlingz/games/reversi/joinfork/Board.java
+++ b/src/main/java/de/earthlingz/games/reversi/joinfork/Board.java
@@ -18,8 +18,12 @@
 
         WHITE, BLACK, SELECTABLE
     }
+    
+    STATE h8 = null; //save h8 in an additional state (hurray for no unsigned longs in java)
+    
     private List<BoardMove> moves = new ArrayList<>(60);
-    private STATE[] boolboard;
+    private long blackFields = 0; //nothing is set (negative values represent no stone/stone and positive values black/white)
+    private long whiteFields = 0;
     private boolean nextPlayerBlack;
     protected static final Logger log = LoggerFactory.getLogger(Board.class);
     private final boolean skipCheck; //determine whether to check for bad/illegal moves (used for performance)
@@ -36,11 +40,12 @@
         super();
         skipCheck = pSkipChecks;
         nextPlayerBlack = true;
-        boolboard = new STATE[64];
-        boolboard[4*8 + 4]=STATE.WHITE;//e5
-        boolboard[3*8 + 3]=STATE.WHITE;//d4
-        boolboard[3*8 + 4]=STATE.BLACK;//d5
-        boolboard[4*8 + 3]=STATE.BLACK;//e4
+
+        setStone(4, 4, 0);//e5 --> White (Field Occupied)
+        setStone(3, 3, 0);//d4 --> White (Field Occupied)
+        setStone(3, 4, 1);//d5 --> Black (Field Occupied)
+        setStone(4, 3, 1);//e4 --> Black (Field Occupied)
+
         blackStones = 2;
         whiteStones = 2;
     }
@@ -49,7 +54,9 @@
         super();
         skipCheck = pSkipChecks;
         nextPlayerBlack = toCopy.isNextPlayerBlack();
-        boolboard =deepCopy(toCopy.boolboard);
+        blackFields = toCopy.blackFields;
+        whiteFields = toCopy.whiteFields;
+        h8 = toCopy.h8;
         moves = new ArrayList<>();
         blackStones = toCopy.getBlackStones();
         whiteStones = toCopy.getWhiteStones();
@@ -57,27 +64,69 @@
         possibleMoves = Collections.unmodifiableSet(toCopy.getPossibleMoves());
     }
     
-    public Board(boolean pSkipChecks, STATE[] pBoard, boolean pNextPlayerBlack) {
+    public Board(boolean pSkipChecks, long pBoard, long fields, boolean pNextPlayerBlack) {
         blackStones = 0;
         whiteStones = 0;
         skipCheck=pSkipChecks;
         nextPlayerBlack = pNextPlayerBlack;
-        boolboard = deepCopy(pBoard);
+        blackFields = pBoard;
+        whiteFields = fields;
         for(int i = 0; i < 8; i++)
         {
             for(int j = 0; j < 8; j++)
             {
-                if(boolboard[i*8 + j] == STATE.BLACK)
+                if(!isEmpty(i, j) && isStone(i, j, 1))
                 {
                     blackStones++;
                 }
-                else if(boolboard[i*8 + j] == STATE.WHITE)
+                else if(!isEmpty(i, j) && isStone(i, j, 0))
                 {
                     whiteStones++;
                 }
             }
         }
     }
+    
+    protected final boolean isEmpty(int row, int column)
+    {
+        if(row == 7 && column == 7) //h8 is special
+        {
+            return h8 == null;
+        }
+        return ((whiteFields | blackFields) & (1L << (row * 8 + column))) == 0;
+    }
+    
+    protected final boolean isStone( int row, int column, long stone)
+    {
+        if(row == 7 && column == 7) //h8 is special
+        {
+            return h8 == (stone == 1?STATE.BLACK:STATE.WHITE);
+        }
+        else if(stone == 0)
+        {
+           return (whiteFields & (1L << (row * 8 + column))) > 0;
+        }
+        return (blackFields & (1L << (row * 8 + column))) > 0;
+    }
+    
+    protected final void setStone(int row, int column, long flip)
+    {
+        if(row == 7 && column == 7)
+        {
+            h8 = (flip == 1?STATE.BLACK:STATE.WHITE);
+        }
+        else if(flip == 1)
+        {
+            whiteFields = whiteFields & ~(1L << (row * 8 + column));
+            blackFields = blackFields | (1L << (row * 8 + column)); //turn both flags on
+        }
+        else
+        {
+            whiteFields = whiteFields | (1L << (row * 8 + column));
+            blackFields = blackFields & ~(1L << (row * 8 + column));//turn first flag on and second flag off
+        }
+    }
+    
 
     /**
      * 0-based Grid (a=0 ... h = 7, 1 = 0, 8 = 7)
@@ -86,10 +135,10 @@
      * @param column
      */
     public final boolean makeMove(int row, int column) {
-        if(log.isDebugEnabled()) {log.debug("Before: " + toString(boolboard));}
+//        if(log.isDebugEnabled()) {log.debug("Before: " + toStringBoard());}
 
         BoardMove move = new BoardMove(row, column);
-        if(log.isDebugEnabled()) {log.debug(move.toString() + "-" + (nextPlayerBlack?"black":"white"));}
+//        if(log.isDebugEnabled()) {log.debug(move.toString() + "-" + (nextPlayerBlack?"black":"white"));}
 
         //assume that skipCheck = true is only used when you are sure that values passed here are legal Moves
         if (!skipCheck && moves.contains(move)) {
@@ -103,7 +152,7 @@
             if (!flipped) {
                 return false;
             }
-            if(log.isDebugEnabled()) {log.debug("Flipped: " + toString(boolboard));}
+//            if(log.isDebugEnabled()) {log.debug("Flipped: " + toStringBoard());}
         } else {
             log.warn("IllegalMove: " + move.toString());
             markNextMoves();
@@ -118,13 +167,13 @@
                 nextPlayerBlack = true;
                 canMove = markNextMoves();
                 if (canMove) {
-                    if(log.isDebugEnabled()) {log.debug("White has to skip");}
+                    //if(log.isDebugEnabled()) {log.debug("White has to skip");}
                     
                 }
                 else
                 {
                     finished = true;
-                    if(log.isDebugEnabled()) {log.debug("End of Game");}
+                    //if(log.isDebugEnabled()) {log.debug("End of Game");}
                 }
             }
 
@@ -135,18 +184,18 @@
                 nextPlayerBlack = false;
                 canMove = markNextMoves();
                 if (canMove) {
-                    if(log.isDebugEnabled()) {log.debug("Black has to skip");}                  
+                    //if(log.isDebugEnabled()) {log.debug("Black has to skip");}                  
                 }
                 else
                 {
                     finished = true;
-                    if(log.isDebugEnabled()) {log.debug("End of Game");}
+                    //if(log.isDebugEnabled()) {log.debug("End of Game");}
                 }
             }
 
         }
         
-        if(log.isDebugEnabled()) {log.debug("NextPlayer: " + (nextPlayerBlack?"black":"white"));};
+        //if(log.isDebugEnabled()) {log.debug("NextPlayer: " + (nextPlayerBlack?"black":"white"));};
         
         return true;
     }
@@ -169,8 +218,9 @@
      * @param executeFlip if false then only a check is performed, no actual flipping is done
      * @return 
      */
-    private boolean flip( int row, int column, STATE endflip, boolean executeFlip) {
-        STATE flip = (endflip == STATE.BLACK) ? STATE.WHITE : STATE.BLACK;
+    private boolean flip( int row, int column, STATE pEndflip, boolean executeFlip) {
+        long toFlip = (pEndflip == STATE.BLACK) ? 0 : 1;
+        long endflip = (pEndflip == STATE.BLACK) ? 1 : 0;
 
         int flipped = 0;
         //look for flip in every direction
@@ -191,9 +241,10 @@
                 continue; //at the end of the board
             }
             
-            if (boolboard[nextRow*8 + nextColumn] == flip) { //the direction is right, stone of opposite colour in that direction
-//                if (log.isTraceEnabled()) {
-//                    log.trace("Flip candidate found for " + dir);
+//            log.info(nextRow + "/" + nextRow + "/" + isEmpty(nextRow, nextColumn) + "/" + isStone(nextRow, nextColumn, toFlip) + "/" + isStone(nextRow, nextColumn, endflip));
+            if (isStone(nextRow, nextColumn, toFlip)) { //the direction is right, stone of opposite colour in that direction
+//                if (log.isDebugEnabled()) {
+//                    log.debug("Flip candidate found for " + dir);
 //                }
                 
                 //can be flipped, if we can find a beginning i.e. stone of other colour in same direction
@@ -208,31 +259,32 @@
                         break; //at the end of the board
                     }
                     //if we find an empty field break;
-                    if (boolboard[nextRow*8 + nextColumn] != STATE.BLACK && boolboard[nextRow*8 + nextColumn] != STATE.WHITE) {
+                    if (isEmpty(nextRow, nextColumn)) {
                         break;
                     }
 
-                    if (boolboard[nextRow*8 + nextColumn] == endflip) { //found a stone of same colour, lines between can be flipped
+                    if (isStone(nextRow, nextColumn, endflip)) { //found a stone of same colour, lines between can be flipped
+//                       if (log.isDebugEnabled()) {
+//                            log.debug("Possible Move found for Flip " + dir);
+//                        }
                         if(!executeFlip) //don't change the board, just check
                         {
                             return true;
                         }
-//                        if (log.isTraceEnabled()) {
-//                            log.trace("Starting to Flip for " + dir);
-//                        }
+
                         while (!(row == nextRow && column == nextColumn)) //backwards flipping, flip till we reach the start
                         {
                             nextRow = nextRow - dir.getHor();
                             nextColumn = nextColumn - dir.getVer();
                             
-//                            if (log.isTraceEnabled()) {
-//                                log.trace("Flipped: " + nextColumn + "/" + nextRow + " to " + endflip);
+//                            if (log.isDebugEnabled()) {
+//                                log.debug("Flipped: " + nextColumn + "/" + nextRow + " to " + endflip);
 //                            }
                             
                             //flip and count stones that are not already flipped
-                            if(boolboard[nextRow*8 + nextColumn] != endflip)
+                            if(!isStone(nextRow, nextColumn, endflip))
                             {
-                                boolboard[nextRow*8 + nextColumn] = endflip;
+                                setStone(nextRow, nextColumn, endflip);
                                 flipped++;
                             }
                         }
@@ -242,15 +294,15 @@
             }
 
             if (flipped == 0) {
-//                if (log.isTraceEnabled()) {
-//                    log.trace(dir + " did not flip");
+//                if (log.isDebugEnabled()) {
+//                    log.debug(dir + " did not flip");
 //                }
             }
         }
         
         if(executeFlip)
         {
-            if(flip == STATE.WHITE)
+            if(toFlip == 0) //WHITE
             {
                 blackStones += flipped;
                 whiteStones -= (flipped - 1); //flipped contains the new stone
@@ -266,25 +318,34 @@
     }
 
     public STATE getState(int row, int column) {
-        return boolboard[row*8 + column];
+        if (isStone(row, column, 1)) {
+            return STATE.BLACK;
+        } else if (isStone(row, column, 0)) {
+            return STATE.WHITE;
+        } else {
+            if(possibleMoves != null && possibleMoves.contains(new BoardMove(row, column)))
+            {
+                return STATE.SELECTABLE;
+            }
+            return null;
+        }
     }
 
-    public String toString(STATE[] board) {
+    public String toStringBoard() {
         StringBuilder build = new StringBuilder("\n");
         build.append("_|a|b|c|d|e|f|g|h|\n");
         for (int i = 0; i < 8; i++) {
             build.append(i+1).append("|");
             for (int j = 0; j < 8; j++) {
-                if (board[i*8 + j] != null) {
-                    STATE state = board[i*8 + j];
-                    if (state == STATE.BLACK) {
-                        build.append("b|");
-                    } else if (state == STATE.WHITE) {
-                        build.append("w|");
-                    } else if (state == STATE.SELECTABLE) {
-                        build.append("o|");
-                    }
-                } else {
+                STATE state = getState(i, j);
+                if (state == STATE.BLACK) {
+                    build.append("b|");
+                } else if (state == STATE.WHITE) {
+                    build.append("w|");
+                } else if (state == STATE.SELECTABLE) {
+                    build.append("o|");
+                } else
+                {
                     build.append("_|");
                 }
             }
@@ -298,19 +359,9 @@
         boolean marked = false;
         possibleMoves = new HashSet<>();
         for (int i = 0; i < 64; i++) {
-            if (boolboard[i] == null || boolboard[i] == STATE.SELECTABLE) {
-                if (isLegalMove(i/8, i%8)) {
-                    boolboard[i] = STATE.SELECTABLE;
-                    possibleMoves.add(new BoardMove(i/8, i%8));
-                    marked = true;
-                }
-                else
-                {
-                    boolboard[i] = null; //unsets fields that were selectable
-                }
-
-            } else {
-                continue; //Field is occupied
+            if (isEmpty(i/8, i%8) && isLegalMove(i/8, i%8)) {
+               possibleMoves.add(new BoardMove(i/8, i%8));
+               marked = true;
             }
         }
 
@@ -327,15 +378,15 @@
 
     @Override
     public String toString() {
-        return "Board{" + "moves=" + moves + ", finished=" + finished +", board=" + toString(boolboard) + (moves.size() > 0 ? ", lastmove=" + moves.get(moves.size() - 1) :"") + ", nextPlayerBlack=" + nextPlayerBlack + '}';
+        return "Board{" + "moves=" + moves + ", finished=" + finished +", board=" + toStringBoard() + (moves.size() > 0 ? ", lastmove=" + moves.get(moves.size() - 1) :"") + ", nextPlayerBlack=" + nextPlayerBlack + '}';
     }
 
     public boolean isNextPlayerBlack() {
         return nextPlayerBlack;
     }
 
-    public STATE[] getBoolboard() {
-        return deepCopy(boolboard);
+    public long getBoolboard() {
+        return blackFields;
     }
     
     public int getBlackStones() {
@@ -354,13 +405,5 @@
     public boolean isFinished()
     {
         return finished;
-    }
-    
-    private STATE[] deepCopy(STATE[] boolboard) {
-        STATE[] result = new STATE[64];
-
-        System.arraycopy(boolboard, 0, result, 0, 64);
-
-        return result;
     }
 }
\ No newline at end of file
diff --git a/src/main/java/de/earthlingz/games/reversi/joinfork/WrappedBoard.java b/src/main/java/de/earthlingz/games/reversi/joinfork/WrappedBoard.java
index fe59f26..a9ac9a9 100644
--- a/src/main/java/de/earthlingz/games/reversi/joinfork/WrappedBoard.java
+++ b/src/main/java/de/earthlingz/games/reversi/joinfork/WrappedBoard.java
@@ -19,8 +19,9 @@
         super(skipChecks);
     }
 
-    private WrappedBoard(STATE[] transpose, boolean pNextPlayerBlack, boolean skipChecks) {
-        super(skipChecks, transpose, pNextPlayerBlack);
+    private WrappedBoard(long transpose, boolean pNextPlayerBlack, boolean skipChecks) {
+        super(skipChecks);
+        //(skipChecks, transpose, pNextPlayerBlack);
     }
 
     public boolean makeMove(String nextMove) {
@@ -31,7 +32,7 @@
         }
         nextMove = nextMove.toLowerCase();
 
-        if(log.isDebugEnabled()) {log.debug(nextMove);};
+        //if(log.isDebugEnabled()) {log.debug(nextMove);};
         
         int column = nextMove.charAt(0) - (int) 'a';
         int row = Integer.parseInt(nextMove.substring(1, 2)) - 1;
@@ -57,14 +58,14 @@
     }
 
     public String backpose() {
-        STATE[] board = getBoolboard();
         StringBuilder build = new StringBuilder("");
         for (int i = 0; i < 8; i++) {
             for (int j = 0; j < 8; j++) {
-                if (board[i*8 + j] != null) {
+                STATE state = getState(i, j);
+                if (state != null) {
                     char c = (char) (i + 'a');
                     String pos = "" + c + (j + 1);
-                    STATE state = board[i*8 + j];
+
                     if (state == STATE.BLACK) {
                         build.append(pos).append("b");
                     } else if (state == STATE.WHITE) {
@@ -80,8 +81,8 @@
         return build.toString();
     }
 
-    private static STATE[] transpose(String board) {
-        STATE[] boolBoard = new STATE[64];
+    private static long transpose(String board) {
+        long boolBoard = 0;
         Pattern p = Pattern.compile("[a-h][1-8][w|b],");
         Matcher m = p.matcher(board);
         while (m.find()) {
@@ -95,7 +96,7 @@
             char sRow = m.group().charAt(0);
             int column = Integer.parseInt(m.group().substring(1, 2)) - 1;
             int row = sRow - (int) 'a';
-            boolBoard[row*8 + column] = state;
+            //boolBoard[row*8 + column] = state;
         }
         return boolBoard;
     }
@@ -113,6 +114,7 @@
         WrappedBoard result = new WrappedBoard(true); //skip checks
         for(String move : moves)
         {
+            //log.info(move + ": " + result.toStringBoard());
             boolean res = result.makeMove(move);
             if(!res)
             {
diff --git a/src/test/java/de/earthlingz/games/reversi/joinfork/BoardTest.java b/src/test/java/de/earthlingz/games/reversi/joinfork/BoardTest.java
index 7cd0858..e46048b 100644
--- a/src/test/java/de/earthlingz/games/reversi/joinfork/BoardTest.java
+++ b/src/test/java/de/earthlingz/games/reversi/joinfork/BoardTest.java
@@ -26,7 +26,7 @@
     @BeforeClass
     public static void setUpClass() throws Exception {
         final ConsoleAppender consoleAppender = new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN));
-        consoleAppender.setThreshold(Level.INFO);
+        consoleAppender.setThreshold(Level.DEBUG);
         Logger.getRootLogger().addAppender(consoleAppender);
     }
     
@@ -35,18 +35,66 @@
         Logger.getRootLogger().removeAllAppenders();
     }
     
+    @Test public void bitmasks()
+    {                       
+        Board b = new Board(true, 0, 0, true);
+        
+        for(int i = 1; i < 8; i++)
+        {
+            for(int j = 1; j < 8; j++)
+            {
+                assertTrue("Empty: " + b.getBoolboard(), b.isEmpty(i, j));
+            }
+        }
+
+        System.out.println((long)1 << 63);
+        
+        //black
+        assertTrue("Empty: " + b.getBoolboard(), b.isEmpty(5, 5));
+        b.setStone(5, 5, 1);
+        assertFalse("Not Empty: " + b.getBoolboard(), b.isEmpty(5, 5));
+        assertTrue("Black: " + b.getBoolboard(), b.isStone(5, 5, 1));
+        assertEquals(STATE.BLACK, b.getState(5, 5));
+        
+        assertTrue("Empty: " + b.toString(), b.isEmpty(0, 0));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(1, 1));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(2, 2));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(3, 3));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(4, 4));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(6, 6));
+        assertTrue("Empty: " + b.toString(), b.isEmpty(7, 7));
+        
+        
+        //white
+        assertTrue("Empty: " + b.toString(), b.isEmpty(6, 6));
+        b.setStone(6, 6, 0);
+        assertFalse("Not Empty: " + b.getBoolboard(), b.isEmpty(6, 6));
+        assertTrue("White:" + b.getBoolboard(), b.isStone(6, 6, 0));
+        assertEquals(STATE.WHITE, b.getState(6, 6));
+        
+        b.setStone(7, 7, 0); //h8 is special
+        assertFalse("Not Empty: " + b.getBoolboard(), b.isEmpty(7, 7));
+        assertEquals(STATE.WHITE, b.getState(7, 7));
+        assertTrue("White:" + b.getBoolboard(), b.isStone(7, 7, 0));
+    }
+    
     @Test public void playGameNoChecks()
     {
         Board b = new Board(true);
         //wb
         //bw     
-        assertEquals("Black", b.getState(3, 4), STATE.BLACK);
-        assertEquals("Black", b.getState(4, 3), STATE.BLACK);
-        assertEquals("White", b.getState(3, 3), STATE.WHITE);
-        assertEquals("White", b.getState(4, 4), STATE.WHITE);
+        assertEquals("Black " + b, STATE.BLACK, b.getState(3, 4));
+        assertEquals("Black " + b, STATE.BLACK, b.getState(4, 3));
+        assertEquals("White " + b, STATE.WHITE, b.getState(3, 3));
+        assertEquals("White " + b, STATE.WHITE, b.getState(4, 4));
+        assertTrue("Black " + b, b.isStone(3, 4, 1));
+        assertTrue("Black " + b, b.isStone(4, 3, 1));
+        assertTrue("White " + b, b.isStone(3, 3, 0));
+        assertTrue("White " + b, b.isStone(4, 4, 0));
         
-        assertTrue(b.markNextMoves()); //mark available moves
-        assertTrue(b.markNextMoves()); //mark available moves, must work twice
+        
+        assertTrue("" +b, b.markNextMoves()); //mark available moves
+        assertTrue("" +b, b.markNextMoves()); //mark available moves, must work twice
         
         assertEquals("Black", b.getState(3, 4), STATE.BLACK);
         assertEquals("Black", b.getState(4, 3), STATE.BLACK);
@@ -89,15 +137,10 @@
          b.markNextMoves(); //mark available moves
         
         //all marked fields have to be playable
-        for(int i = 0; i < 8; i++)
+        for(BoardMove move : b.getPossibleMoves())
         {
-            for (int j = 0; j < 8; j++)
-            {
-                if(b.getBoolboard()[i*8 + j] == STATE.SELECTABLE)
-                {
-                    assertTrue(i +"/" +j + " is not legal but was marked as legal",b.isLegalMove(i, j));
-                }
-            }
+           assertTrue(move+ " is not legal but was marked as legal",b.isLegalMove(move.getRow(), move.getColumn()));
+
         }
         //try this move again, should fail
        assertFalse(b.makeMove(2, 3));  
@@ -149,7 +192,7 @@
         assertEquals(1, b.getWhiteStones());
         assertEquals(4, b.getBlackStones());
         
-        assertEquals(false, b.isNextPlayerBlack()); //white has next move
+        assertEquals(b.toStringBoard(), false, b.isNextPlayerBlack()); //white has next move
         //nothing has changed
         assertEquals("Black", b.getState(2, 3), STATE.BLACK); //move we made
         assertEquals("Black", b.getState(3, 4), STATE.BLACK);
diff --git a/src/test/java/de/earthlingz/games/reversi/joinfork/GameSolverTest.java b/src/test/java/de/earthlingz/games/reversi/joinfork/GameSolverTest.java
index b5787a3..75e490a 100644
--- a/src/test/java/de/earthlingz/games/reversi/joinfork/GameSolverTest.java
+++ b/src/test/java/de/earthlingz/games/reversi/joinfork/GameSolverTest.java
@@ -70,7 +70,7 @@
         Assert.assertEquals(44, b.getWhiteStones());
     }
        
-    @Test(timeout=10000) public void whiteWin2() { //10 Seconds TimeOut
+    @Test public void whiteWin2() { //10 Seconds TimeOut
         //    WOC 2010, round 1
         //    ORTIZ George 	22
         //    BERG Matthias 	44
diff --git a/src/test/java/de/earthlingz/games/reversi/joinfork/JoinForkGameSolverTest.java b/src/test/java/de/earthlingz/games/reversi/joinfork/JoinForkGameSolverTest.java
index 27a0c15..3a51a5c 100644
--- a/src/test/java/de/earthlingz/games/reversi/joinfork/JoinForkGameSolverTest.java
+++ b/src/test/java/de/earthlingz/games/reversi/joinfork/JoinForkGameSolverTest.java
@@ -132,16 +132,19 @@
             LOG.info("Round " + (i + 1) + "End:" + new Date());
         }
 
-        //0 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 1Begin:Thu Apr 26 10:40:28 CEST 2012
-        //188 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 1End:Thu Apr 26 10:40:29 CEST 2012
-        //203 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 2Begin:Thu Apr 26 10:40:29 CEST 2012
-        //1968 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 2End:Thu Apr 26 10:40:30 CEST 2012
-        //1968 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 3Begin:Thu Apr 26 10:40:30 CEST 2012
-        //9232 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 3End:Thu Apr 26 10:40:38 CEST 2012
-        //9232 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 4Begin:Thu Apr 26 10:40:38 CEST 2012
-        //93316 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 4End:Thu Apr 26 10:42:02 CEST 2012
-        //93316 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 5Begin:Thu Apr 26 10:42:02 CEST 2012
-        //1109695 [main] INFO de.earthlingz.games.reversi.joinfork.GameSolverTest  - Round 5End:Thu Apr 26 10:58:58 CEST 2012
+        //0 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 1Begin:Thu Apr 26 12:17:33 CEST 2012
+        //109 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 1End:Thu Apr 26 12:17:33 CEST 2012
+        //109 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 2Begin:Thu Apr 26 12:17:33 CEST 2012
+        //1016 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 2End:Thu Apr 26 12:17:34 CEST 2012
+        //1016 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 3Begin:Thu Apr 26 12:17:34 CEST 2012
+        //4719 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 3End:Thu Apr 26 12:17:38 CEST 2012
+        //4719 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 4Begin:Thu Apr 26 12:17:38 CEST 2012
+        //49096 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 4End:Thu Apr 26 12:18:22 CEST 2012
+        //49096 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 5Begin:Thu Apr 26 12:18:22 CEST 2012
+        //594430 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 5End:Thu Apr 26 12:27:27 CEST 2012
+        //594430 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 6Begin:Thu Apr 26 12:27:27 CEST 2012
+        //9563029 [main] INFO de.earthlingz.games.reversi.joinfork.JoinForkGameSolverTest  - Round 6End:Thu Apr 26 14:56:56 CEST 2012
+
     }
 
     private List<String> split(String game) {
diff --git a/src/test/java/de/earthlingz/games/reversi/joinfork/ReplayTest.java b/src/test/java/de/earthlingz/games/reversi/joinfork/ReplayTest.java
index 1fea153..2faae45 100644
--- a/src/test/java/de/earthlingz/games/reversi/joinfork/ReplayTest.java
+++ b/src/test/java/de/earthlingz/games/reversi/joinfork/ReplayTest.java
@@ -21,8 +21,8 @@
 
     @BeforeClass
     public static void setUpClass() throws Exception {
-        //final ConsoleAppender appender = new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN));
-        AppenderSkeleton appender = new AppenderSkeletonImpl();
+        final ConsoleAppender appender = new ConsoleAppender(new PatternLayout(PatternLayout.TTCC_CONVERSION_PATTERN));
+        //AppenderSkeleton appender = new AppenderSkeletonImpl();
 
         Logger.getRootLogger().addAppender(appender);
         Logger.getRootLogger().setLevel(Level.TRACE);
